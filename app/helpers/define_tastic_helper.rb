# frozen_string_literal: true

# Like the creator of formtastic, I was unsatisfied with the default view-html generated by rails.
# These helper methods help cleaning it up a bit.
#
# DSL:
#
#    <% definition_list_for @obj do %>
#        <%= define_unless_blank :main_category %>
#        <%= define_unless_blank :sub_category %>
#        <%= define_unless_blank :description %>
#        <%= define_unless_blank :conversion_factor %>
#        <%= define_unless_blank :turnover, {modifier: :number_to_currency} %>
#    <% end %>
module DefineTasticHelper

  def render_unless_blank_definition description, value, options={}
    classname = options[:classname]
    if @define_tastic_render_as == :table
      style = " style=\"width: #{@define_tastic_key_width}\"" if @define_tastic_key_width
      "<tr#{" class=\"#{classname}\"" if classname}><th#{style}>#{description}:</th><td>#{sanitize value}</td></tr>".html_safe unless value.blank?
    else
      "<dt#{" class=\"#{classname}\"" if classname}>#{description}:</dt><dd#{" class=\"#{classname}\"" if classname}>#{sanitize value}</dd>".html_safe unless value.blank?
    end
  end

  def define_unless_blank property, options={}
    description = options[:description] ? options[:description] : @define_tastic_object_klass.human_attribute_name(property)

    render_unless_blank_definition(description, value_render(property,options), options)
  end

  def humanize_value val, options={}
    if val.is_a? ActiveRecord::Base and (val.methods.include?(:name) or val.methods.include?("name"))
      val = val.send(:name)
    end
    if val.is_a? Date
      val = I18n.l(val, {format: :short})
    elsif (val.is_a? DateTime or val.is_a? Time)
      val = I18n.l(val, {format: :short})
    elsif (val.is_a? TrueClass)
      val = "Ja"
    elsif (val.is_a? FalseClass)
      val = "Nee"
    end
    if options[:human_attributize_value]
      val = @define_tastic_object_klass.send(:human_attribute_name,val)
    end
    val
  end


  def value_render property, options={}
    value = nil

    if options[:override_value]
      value = options[:override_value]
    else
      modifier_func = options[:modifier]

      if property.is_a? Symbol
        value = @define_tastic_object.send(property)
      else
        value = property
      end

      if value.is_a? Range
        values = [value.min, value.max]
      elsif value.methods.include? :collect
        values = value.collect{|val| val}
      else
        values = [value]
      end

      values = values.compact.collect do |val|
        val = apply_modifier_to_value(modifier_func, val)
        humanize_value(val, options.select{|k,v| k == :human_attribute_value})
      end

      value = if value.is_a?(Range)
          values.join("-")
        else
          values.to_sentence
        end
    end
    return value.html_safe
  end

  def apply_modifier_to_value modifier, value, obj=self

    if value and modifier
      return obj.send(modifier,value)
    end
    return value
  end

  def upcase value
    value.to_s.upcase
  end

  def link_to_with_name object, options={}
    options = {nil_value: "-"}.merge(options)
    if object.class == Array
      subject = object.last
    else
      subject = object
    end

    name = options[:nil_value]
    name = subject.name if subject.methods.include? :name
    name = subject.title if subject.methods.include? :title

    return object ? link_to(name, object) : options[:nil_value]
  end


  def definition_list_for object, *args, &block
    @define_tastic_object = object
    @define_tastic_object_klass = object.class
    @define_tastic_render_as = :dl
    html_string = ""

    if args[0]
      if args[0].is_a? String
        html_string += "<h3>#{args[0]}</h3>"
      else
        if args[0][:render_as]
          @define_tastic_render_as = args[0][:render_as] == :table ? :table : :dl
        end
        if args[0][:key_width]
          @define_tastic_key_width = args[0][:key_width]
        end
      end

    end

    block_contents = capture(&block).to_s

    html_string = block_contents.strip.empty? ? "" : ["<#{@define_tastic_render_as}>", block_contents, "</#{@define_tastic_render_as}>"].join("\n")

    @define_tastic_object = object
    @define_tastic_object_klass = nil

    return html_string.html_safe
  end

end





#
# # Like the creator of formtastic, I was unsatisfied with the default view-html generated by rails.
# # These helper methods help cleaning it up a bit.
# #
# # DSL:
# #
# #    <% definition_list_for @obj do %>
# #        <%= define_unless_blank :main_category %>
# #        <%= define_unless_blank :sub_category %>
# #        <%= define_unless_blank :description %>
# #        <%= define_unless_blank :conversion_factor %>
# #        <%= define_unless_blank :turnover, nil, {:modifier=>:number_to_currency} %>
# #    <% end %>
#
#
#   def render_unless_blank_definition description, value
#     "<dt>#{description}:</dt><dd>#{value}</dd>" unless value.blank?
#   end
#
#   def define_unless_blank property, description=nil, options={}
#     description = @object_klass.human_attribute_name(property) unless description
#     value = @object.read_attribute property
#     modifier = options[:modifier]
#     value = eval "#{modifier} '#{value}'" unless value.blank?
#     render_unless_blank_definition(description, value)
#   end
#
#   def link_to_with_name object
#     if object.class == Array
#       subject = object.last
#     else
#       subject = object
#     end
#
#     name = "geen naam opgegeven"
#     name = subject.name if subject.has_attribute? :name
#     name = subject.title if subject.has_attribute? :title
#     return link_to(name, object)
#   end
#
#
#   def definition_list_for object, *args, &block
#     @object = object
#     @object_klass = object.class
#     if args[0]
#       concat('<h3>'.html_safe)
#       concat(args[0])
#       concat('</h3>'.html_safe)
#     end
#     concat('<dl>'.html_safe) #inpsired by the form_for helper
#     fields_for(object, *(args), &proc)
#     concat('</dl>'.html_safe)
#   end
